<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Dot Counting Game</title>
<style>
  /* Full blank screen except for dots and edge feedback */
  html,body {
    height:100%;
    margin:0;
    background: #ffffff;
    font-family: Arial, Helvetica, sans-serif;
    overflow:hidden;
    color:#111;
  }
  .container { height:100%; display:flex; align-items:center; justify-content:center; position:relative; }
  canvas#gameCanvas { background:transparent; display:block; }
  .overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(255,255,255,0.95); z-index:50; text-align:center; padding:20px; }
  .card { max-width:740px; width:100%; border-radius:12px; padding:24px; box-shadow:0 6px 20px rgba(0,0,0,0.12); background:linear-gradient(180deg,#fff,#f7f7f7); }
  button { padding:10px 16px; font-size:16px; border-radius:8px; border:1px solid #ccc; cursor:pointer; background:white; }
  .muted { color:#666; font-size:14px; }
  .edge { position:fixed; z-index:40; pointer-events:none; transition:opacity 0.15s; opacity:0; }
  .edge.left, .edge.right { top:0; bottom:0; width:6%; }
  .edge.top, .edge.bottom { left:0; right:0; height:6%; }
  .edge.left { left:0; } .edge.right { right:0; } .edge.top { top:0; } .edge.bottom { bottom:0; }
  .edge.active { opacity:1; }
  .edge.green{background:rgba(44,183,47,0.85);} .edge.red{background:rgba(231,76,60,0.85);}
  .statbox { position:fixed; left:12px; top:12px; background:rgba(255,255,255,0.9); padding:8px 12px; border-radius:8px; box-shadow:0 4px 10px rgba(0,0,0,0.08); z-index:60; font-size:13px; }
  .linkish { color: #1a73e8; text-decoration:underline; cursor:pointer; }
  footer.note { position:fixed; right:12px; bottom:12px; font-size:12px; color:#666; }
</style>
</head>
<body>
  <div class="container">
    <canvas id="gameCanvas"></canvas>
    <div id="edgeLeft" class="edge left"></div>
    <div id="edgeRight" class="edge right"></div>
    <div id="edgeTop" class="edge top"></div>
    <div id="edgeBottom" class="edge bottom"></div>
    <div id="statbox" class="statbox" style="display:none">
      <div>Round: <span id="statRound">0</span>/<span id="statRoundsTotal">0</span></div>
      <div>Correct: <span id="statCorrect">0</span></div>
      <div class="muted">Press keys 1–9 and 0 (for 10)</div>
    </div>
    <div id="overlay" class="overlay">
      <div class="card" id="card">
        <h1>Dot Counting Game</h1>
        <p class="muted">
          You will see a set of dots (between 2 and 8) for half a second.<br/>
          The dots then disappear — press the number on your keyboard (1–10) for how many you saw.
        </p>
        <p class="muted">
          Each round: 0.5s dots → 2s to answer → 1s feedback. Default game has 60 rounds (≈3 minutes).
        </p>
        <div style="display:flex;gap:8px;justify-content:center;margin-top:12px;">
          <button id="startBtn">Start full game (60 rounds)</button>
          <button id="practiceBtn">Practice (10 rounds, not recorded)</button>
        </div>
        <hr style="margin:16px 0;" />
        <div style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center;">
          <div><label>Rounds: <input id="roundsInput" type="number" min="10" max="200" step="1" value="60" style="width:80px"/></label></div>
          <div><label>Min dots: <input id="minDots" type="number" min="1" max="9" value="2" style="width:60px"/></label></div>
          <div><label>Max dots: <input id="maxDots" type="number" min="2" max="20" value="8" style="width:60px"/></label></div>
        </div>
        <hr style="margin:16px 0;" />
        <div id="globalStatsArea" class="muted">Loading global stats...</div>
      </div>
    </div>
    <footer class="note">Made with AI</footer>
  </div>

<script>
const CONFIG = {
  dotShowMs: 500,
  responseWindowMs: 2000,
  feedbackMs: 1000,
  defaultRounds: 60,
  practiceDurationSec: 60,
  minDots: 2,
  maxDots: 8,
  firebaseConfig: {
    apiKey: "AIzaSyBijKB23Azm4Gegzad7MhKboTMk9HBgtv0",
    authDomain: "dotcounting.firebaseapp.com",
    projectId: "dotcounting",
    storageBucket: "dotcounting.firebasestorage.app",
    messagingSenderId: "211375705348",
    appId: "1:211375705348:web:123b13fde03814091c1451"
  }
};

let state = {
  roundsTotal: CONFIG.defaultRounds,
  roundIndex: 0,
  currentDots: 0,
  inRound: false,
  awaitingAnswer: false,
  correctCount: 0,
  responseTimes: [],
  roundTimer: null,
  roundTimeoutHandle: null,
  startTimeEpoch: null,
  practiceMode: false,
  dotHistory: []
};

/* Firebase setup */
let firestore = null;
if (CONFIG.firebaseConfig) {
  const s = document.createElement('script');
  s.src = "https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js";
  document.head.appendChild(s);
  const s1 = document.createElement('script');
  s1.src = "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js";
  document.head.appendChild(s1);
  const s2 = document.createElement('script');
  s2.src = "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js";
  document.head.appendChild(s2);
  s2.onload = () => {
    firebase.initializeApp(CONFIG.firebaseConfig);
    firestore = firebase.firestore();
    firebase.auth().signInAnonymously().catch(console.error);
    fetchGlobalStats();
  };
}

/* DOM refs */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
const practiceBtn = document.getElementById('practiceBtn');
const roundsInput = document.getElementById('roundsInput');
const minDotsInput = document.getElementById('minDots');
const maxDotsInput = document.getElementById('maxDots');
const statbox = document.getElementById('statbox');
const statRound = document.getElementById('statRound');
const statRoundsTotal = document.getElementById('statRoundsTotal');
const statCorrect = document.getElementById('statCorrect');
const edges = {
  left: document.getElementById('edgeLeft'),
  right: document.getElementById('edgeRight'),
  top: document.getElementById('edgeTop'),
  bottom: document.getElementById('edgeBottom')
};
const globalStatsArea = document.getElementById('globalStatsArea');

/* Canvas sizing */
function resizeCanvas(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resizeCanvas); resizeCanvas();

/* Draw dots */
function drawDots(n) {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const boxW = canvas.width*0.6, boxH = canvas.height*0.6;
  const startX=(canvas.width-boxW)/2, startY=(canvas.height-boxH)/2;
  const r=12, minDist=r*2.5;
  ctx.fillStyle="#000";
  const positions=[];
  for(let i=0;i<n;i++){
    let tries=0,cx,cy,ok=false;
    while(!ok&&tries<100){
      cx=startX+Math.random()*boxW; cy=startY+Math.random()*boxH; ok=true;
      for(const [px,py] of positions){ if(Math.hypot(cx-px,cy-py)<minDist){ok=false;break;} }
      tries++;
    }
    positions.push([cx,cy]);
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
  }
}
function clearCanvas(){ ctx.clearRect(0,0,canvas.width,canvas.height); }

/* Game flow */
function startGame({rounds,practice=false}){
  CONFIG.minDots=parseInt(minDotsInput.value)||2;
  CONFIG.maxDots=parseInt(maxDotsInput.value)||8;
  state={...state, roundsTotal:rounds, roundIndex:0, currentDots:0, inRound:false,
    awaitingAnswer:false, correctCount:0, responseTimes:[], startTimeEpoch:Date.now(),
    practiceMode:practice, dotHistory:[]};
  overlay.style.display='none'; statbox.style.display='block';
  statRoundsTotal.textContent=state.roundsTotal; updateStatBox();
  window.addEventListener('keydown',onKeyDown);
  setTimeout(nextRound,300);
}

function endGame(){
  window.removeEventListener('keydown',onKeyDown);
  clearCanvas(); statbox.style.display='none';
  const correct=state.correctCount,total=state.roundsTotal;
  const accuracy=total?Math.round(1000*correct/total)/10:0;
  const medianRt=state.responseTimes.length?median(state.responseTimes):null;

  if(!state.practiceMode && firestore &&
     state.roundsTotal===CONFIG.defaultRounds &&
     CONFIG.minDots===2 && CONFIG.maxDots===8){
    const dotStats={};
    state.dotHistory.forEach(e=>{
      if(!dotStats[e.n]) dotStats[e.n]={correct:0,total:0};
      dotStats[e.n].total++; if(e.correct) dotStats[e.n].correct++;
    });
    uploadRunResult({correct,total,accuracy,medianRt,dotStats,createdAt:new Date().toISOString()});
  }
  showFinalOverlay({correct,total,accuracy,medianRt});
  if(firestore) fetchGlobalStats();
}
function median(arr){const s=[...arr].sort((a,b)=>a-b);const m=Math.floor(s.length/2);return s.length? (s.length%2?s[m]:(s[m-1]+s[m])/2):null;}
function nextRound(){
  if(state.roundIndex>=state.roundsTotal){endGame();return;}
  state.inRound=true; state.awaitingAnswer=false; state.roundIndex++; updateStatBox();
  const n=Math.floor(Math.random()*(CONFIG.maxDots-CONFIG.minDots+1))+CONFIG.minDots;
  state.currentDots=n; drawDots(n);
  setTimeout(()=>{ clearCanvas(); state.awaitingAnswer=true; state.roundTimer=Date.now();
    state.roundTimeoutHandle=setTimeout(()=>{ state.awaitingAnswer=false; giveFeedback(false,null);},CONFIG.responseWindowMs);
  },CONFIG.dotShowMs);
}
function onKeyDown(e){
  if(!state.awaitingAnswer)return;
  let val=null;if(/^[1-9]$/.test(e.key))val=parseInt(e.key); else if(e.key==='0')val=10; else return;
  const rt=Date.now()-state.roundTimer; clearTimeout(state.roundTimeoutHandle); state.awaitingAnswer=false;
  const correct=(val===state.currentDots); if(correct)state.correctCount++; state.responseTimes.push(rt);
  state.dotHistory.push({n:state.currentDots,chosen:val,correct});
  updateStatBox(); giveFeedback(correct,val);
}
function updateStatBox(){statRound.textContent=state.roundIndex; statCorrect.textContent=state.correctCount;}
function giveFeedback(correct){const cls=correct?'green':'red'; for(const k in edges)edges[k].className=`edge ${k} ${cls} active`;
  setTimeout(()=>{for(const k in edges)edges[k].className=`edge ${k}`; setTimeout(nextRound,80);},CONFIG.feedbackMs);}

/* UI */
startBtn.addEventListener('click',()=>{startGame({rounds:parseInt(roundsInput.value)||CONFIG.defaultRounds,practice:false});});
practiceBtn.addEventListener('click',()=>{startGame({rounds:10,practice:true});});

function showFinalOverlay({correct,total,accuracy,medianRt}){
  overlay.style.display='flex'; const card=document.getElementById('card');
  card.innerHTML=`
    <h1>Finished!</h1>
    <p class="muted">You got <strong>${correct}</strong> out of <strong>${total}</strong> correct.</p>
    <p class="muted">Accuracy: <strong>${accuracy}%</strong></p>
    <p class="muted">Median reaction time: <strong>${medianRt?Math.round(medianRt)+' ms':'—'}</strong></p>
    <div style="display:flex;gap:8px;justify-content:center;margin-top:12px;">
      <button id="playAgainBtn">Play again</button>
      <button id="backMenuBtn">Back to menu</button>
    </div>
    <hr style="margin:16px 0;">
    <div id="afterGlobal" class="muted">Loading global stats...</div>`;
  document.getElementById('playAgainBtn').addEventListener('click',()=>{startGame({rounds:state.roundsTotal,practice:false});});
  document.getElementById('backMenuBtn').addEventListener('click',()=>{location.reload();});
  if(firestore) fetchGlobalStats().then(renderGlobalStatsInCard);
  else document.getElementById('afterGlobal').textContent='Global stats not configured.';
}

/* Firestore */
async function uploadRunResult(doc){if(!firestore)return; await firestore.collection('dot_game_runs').add(doc);}
async function fetchGlobalStats(){
  try{
    const snap=await firestore.collection('dot_game_runs').orderBy('createdAt','desc').limit(500).get();
    const docs=snap.docs.map(d=>d.data()); if(docs.length===0){globalStatsArea.textContent="No public runs yet."; return [];}
    const totals={count:0,sumAcc:0,best:0}; const perDot={};
    docs.forEach(d=>{
      totals.count++; totals.sumAcc+=d.accuracy||0; if((d.accuracy||0)>totals.best)totals.best=d.accuracy||0;
      if(d.dotStats){for(const [n,s] of Object.entries(d.dotStats)){if(!perDot[n])perDot[n]={correct:0,total:0};
        perDot[n].correct+=s.correct; perDot[n].total+=s.total;}}
    });
    const avg=Math.round(10*totals.sumAcc/totals.count)/10;
    const dotLines=Object.entries(perDot).map(([n,s])=>`${n} dots: ${Math.round(100*s.correct/s.total)}% (${s.total} trials)`).join("<br/>");
    globalStatsArea.innerHTML=`Public runs: ${totals.count} • Avg: ${avg}% • Best: ${totals.best}%<br/><br/>Accuracy by dot count:<br/>${dotLines}`;
    return docs;
  }catch(e){console.warn(e); globalStatsArea.textContent="Error fetching stats."; return [];}
}
function renderGlobalStatsInCard(docs){
  const el=document.getElementById('afterGlobal'); if(!el)return;
  if(!docs.length){el.textContent="No public runs yet.";return;}
  const totals={count:0,sumAcc:0,best:0}; const perDot={};
  docs.forEach(d=>{
    totals.count++; totals.sumAcc+=d.accuracy||0; if((d.accuracy||0)>totals.best)totals.best=d.accuracy||0;
    if(d.dotStats){for(const [n,s] of Object.entries(d.dotStats)){if(!perDot[n])perDot[n]={correct:0,total:0};
      perDot[n].correct+=s.correct; perDot[n].total+=s.total;}}
  });
  const avg=Math.round(10*totals.sumAcc/totals.count)/10;
  const dotLines=Object.entries(perDot).map(([n,s])=>`${n} dots: ${Math.round(100*s.correct/s.total)}% (${s.total} trials)`).join("<br/>");
  el.innerHTML=`Global stats (recent ${docs.length} runs):<br/>Avg accuracy: <strong>${avg}%</strong> • Best: <strong>${totals.best}%</strong><br/><br/>Accuracy by dot count:<br/>${dotLines}`;
}

/* Init */
(async function init(){roundsInput.value=CONFIG.defaultRounds;minDotsInput.value=CONFIG.minDots;maxDotsInput.value=CONFIG.maxDots;})();
</script>
</body>
</html
